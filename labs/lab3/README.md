# Lab 3: A web application for the tram network

Advanced Python Course, Chalmers DAT516, 2025

by Aarne Ranta

<!--
## Note

In 2024, there are no bonus parts, but just one and the same lab for everyone. The movie linked from the Canvas page speaks about "bonus parts". They are now obligatory for everyone, but we will provide more ready-made material for them.

(Added 2024-12-01:) In the movie linked from the course webpage as lecture 8, there are a few things that differ from this year:

- when it says Friday, you should think of Tuesday 3 December 2024
- when it says "bonus parts", they are now just compulsory parts of the lab (but we give some more help on them than when they were optional)
- at 23:30 in the film, `python manage.py migrate tram` was forgotten
- at 47:40, what is called "baseline" is not sufficient this year, because the "bonus parts" are also required. But it is a good idea to start with this "baseline", because you can get it directly from you Lab 2 and you will then know that everything works.
-->

## Purpose

The purpose is to build a web application replicating some functionalities of apps such as [Västtrafik's Travel Planner](https://www.vasttrafik.se/reseplanering/reseplaneraren/).
Your application will:

- display the complete map of tram lines
- highlight shortest paths in terms of time and geographical distance
- make the calculations more precise by taking changes into account
- show actual departures from any stops by clicking at it on the map

Here is an example screenshot:

![shortest-path](../images/app-shortest.png)

In some more detail, here is what the three different screens should look:

- [the home screen](https://htmlpreview.github.io/?https://github.com/aarneranta/chalmers-advanced-python/blob/main/labs/lab3/examples/home.html)
- [the route search form](https://htmlpreview.github.io/?https://github.com/aarneranta/chalmers-advanced-python/blob/main/labs/lab3/examples/find_route.html)
- [the search result](https://htmlpreview.github.io/?https://github.com/aarneranta/chalmers-advanced-python/blob/main/labs/lab3/examples/show_route.html)

The HTML code of each of these pages is already included in the template files in `files/`.
Thus these examples show how the pages should look when you have filled in the templates with your program.

Unlike the official app, ours will not have access to the actual timetables, but just to the distances and times as defined in Labs 1 and 2.
This is of course a severe simplification - but, on the other hand,
our app will be usable for any transport system that can be
represented by the class `TramNetwork`.
Clicking at the created map will give access to actual traffic information from Västtrafik.

Another difference from the official app is that we only run ours in a safe `localhost` environment.
Thereby we do not have to deal with security issues, and it will also be much easier for all groups to finish the project.

The learning outcomes include:

- visualization with more details on positions and colours
- simple front-end construction with HTML
- putting everything together by using a web application framework, Django
- more details of `graphviz` library, various libraries belonging to the `django` framework
- virtual environments (`venv`)

## The task

We will follow a standard line of work for the `django` network.
There are several tutorials available, for instance,

- [Django Girls Tutorial](https://tutorial.djangogirls.org/en/), partly followed in this document
- [w3schools Django Tutorial](https://www.w3schools.com/django/), more concise
- [Official Django Tutorial](https://docs.djangoproject.com/en/3.2/intro/tutorial01/), more details and options

You can look at these for more information, but this lab spec is aimed to be self-contained and sufficient for the lab.

### Files to write

The final structure will look as follows.
The files are obtained as follows:

- created automatically (unmarked in the diagram).
- copied from [files](./files/) (marked `!!`).
- slightly modified from automatic files (marked `!`)
- explained in detail in text but written by you (marked `?`).
- written by you (marked `??`)
- generated by your code (marked `?!`)

```plain
lab3
├── db.sqlite3
├── manage.py
├── mysite
│   ├── __init__.py
│   ├── settings.py !
│   ├── urls.py !
│   └── wsgi.py
├── myvenv
│   └── ... !! (many files, no need to touch)
├── static
│   ├── tramnetwork.json ?!
│   └── tram-url.json !! or ?!
└── tram
    ├── __init__.py
    ├── admin.py
    ├── apps.py
    ├── forms.py ?
    ├── migrations
    │   └── __init__.py
    ├── models.py ?
    ├── templates ?
    │   └── tram ?
    │      ├── find_route.html !!
    │      ├── home.html !!
    │      ├── images
    │      │   ├── gbg_tramnet.svg !! or ?!
    │      │   └── shortest_path.svg ?!
    │      └── show_route.html !!
    ├── tests.py
    ├── urls.py ?
    ├── utils
    │   ├── __init__.py ??
    │   ├── color_tram_svg.py !! 
    │   ├── graphs.py ?? 
    │   ├── trams.py ??
    │   └── tramviz.py ??
    └── views.py !!
```

## The Django workflow

If you have already created the project with copies of the provided
files, you can go down to the section "Your TODO: continue from here".

If not, the following steps must be taken at the first time:

1. create a directory for this project (not the same as in course GitHub):

    ```sh
    $ mkdir lab3
    ```

2. move inside it:

    ```sh
    $ cd lab3
    ```

3. create a Python virtual environment (maybe not necessary, but the best practice):

    ```sh
    $ python3 -m venv myvenv
    ```

    This will create the directory `myvenv` with lots of contents.
4. activate the virtual environment:
    - on Linux/Mac:

      ```sh
      $ source myvenv/bin/activate
      ```

    - on Windows:

      ```sh
      $ myvenv/Scripts/activate.bat
      ```

      or

      ```sh
      $ myvenv/Scripts/activate.ps1
      ```

      Which of these two commands will work depends on what shell you are using. If unsure, try both.
  
    You should now see the string `(myvenv)` prefixed to your command line prompt.
5. Install the necessary Python libraries (`networkx` is only necessary if you did the baseline version of Lab 2):

    ```sh
    $ pip install django
    $ pip install networkx 
    ```

    (notice that you can now use just `python` to run Python, because
  you are in a special environment).
6. Run

    ```sh
    django-admin startproject mysite .
    ```

    (the last dot is necessary: it refers to your working directory, where it creates a directory named
  `mysite` and the file `manage.py`).

At later times (every time you resume working on the project), only the `activate` step (4) is needed.

## Change default settings

In the generated `mysite/settings.py`, you need to change `ALLOWED_HOSTS` to

```python
ALLOWED_HOSTS = ['127.0.0.1']
```

and add to the end

```python
import os
STATIC_ROOT = os.path.join(BASE_DIR, 'static')
```

The `static` directory is needed for some files later, so create it now:

```sh
$ mkdir static
```

You should also copy the file `tramnetwork.json` created in Lab 1 to this directory.

## Test run

This step is needed at the first time:

```sh
python manage.py migrate
```

It creates a database (in the file `db.sqlite3`), which is a standard part of any Django project, even if we don't need it very much at this lab.

Now you can see a first version of your web site:

```sh
$ python manage.py runserver
Starting development server at http://127.0.0.1:8000/
```

The last command will start a server.
Open the URL in a web browser to check if the installation succeeded.
It is just a generic Django-generated page, but it tells you an important message: that your server is up and running.

## Create the tram app

```sh
$ python manage.py startapp tram
```

This creates the directory `tram`, with a lot of predefined contents, but also many things that you will have to complete with your own code.

To recognize this file in your Django website, add the line

```python
'tram.apps.TramConfig',
```

to the end of the `INSTALLED_APPS` list in `mysite/settings.py`.

### Create a model

Create a data model for route searches in `tram/models.py`:

```python
from django.db import models

class Route(models.Model):
    dep = models.CharField(max_length=200)
    dest = models.CharField(max_length=200)

    def __str__(self):
        return self.dep + '-' + self.dest
```

Then migrate it to the database:

```sh
$ python manage.py makemigrations tram
$ python manage.py migrate tram
```

You will see that your `db.sqlite3` file has contents now, but they are in a binary format that you cannot read.

*Note*. In this lab, the application does not add data to the database, but its schema (the `Route` class) is used to structure the queries made via the route search forms.
This is known as the *MVT Design Pattern* (Model-View-Template):

- a model (in `tram/models.py`) is a class that defines a type of data
- a view (to be added to `tram/views.py`) is a function that processes a user request and returns a template
- a template (to be added to `tram/templates/tram`) is an HTML file that shows the data

The database could also be manipulated in the *SQL* language, but Django generates SQL from Python, so that you don't need to learn SQL itself.

### Update URL search patterns

Edit the generated `mysite/urls.py` so that it contains the following:

```python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('tram.urls')),
]
```

The `admin` URL is used for managing the website and requires a login. You can try and create users and passwords, but this is not needed in this lab.
The second `path` includes the URLs given in our app.
For this purpose, you have to create the file `tram/urls.py`:

```python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.tram_net, name='home'),
    path('route/', views.find_route, name='find_route'),
    ]
```

Each path has three arguments:

- the path extending the hostname (seen in the URL field of the browser)
- the "view", i.e. the function called when this URL is requested
- the name of the template file (without the extension `.html`)

### Create views

In order for `tram/urls.py` to work, you have to edit `tram/views.py`, so that it contains the following:

```python
from django.shortcuts import render
from .forms import RouteForm

def tram_net(request):
    return render(request, 'tram/home.html', {})

def find_route(request):
    form = RouteForm()
    return render(request, 'tram/find_route.html', {'form': form})
```

The former function is already all we need to create the start page.
The latter function creates a web form, but does not yet do anything with it: we will return to this later.

Of course, we also need to define the `RouteForm` class and the HTML files.
This is the next topic.

### Create a form

In order for `tram/views.py` to work, we need to create `tram/forms.py`,

```python
from django import forms
from .models import Route

class RouteForm(forms.ModelForm):
    class Meta:
        model = Route
        fields = ('dep', 'dest',)
```

The data model is used here to give a structure to the web form where route queries are made.

### Create templates and static images

The HTML files to be created are actually **templates**, since they contain slots where dynamic data is pasted when the server is running.
The templates reside in a sub-sub-sub-directory, which has to be created first:

```sh
$ mkdir tram/templates
$ mkdir tram/templates/tram
```

Copy the HTML files mentioned in `tram/views.py` from the course GitHub `labs/lab3/files` folder to the newly created `tram/templates/tram`, so that

```sh
$ ls tram/templates/tram/
find_route.html    home.html   show_route.html
```

Also create the `images` subdirectory, which is linked from `home.html`:

```sh
$ mkdir tram/templates/tram/images
```

Then copy the tram network image `gbg_tramnet.svg` (also under `files`) there so that you can view the pages by running the server again,

```sh
$ python manage.py runserver
```

and opening `http://127.0.0.1:8000/` in a web browser.
You will see a home screen with the gorgeous SVG image of Gotheburg tram network.

If you want, you can replace this standard image with your own one: the script `files/create_network_picture.py` does this for you by calling your own `tram.py` on your own `tramnet.json` file.
You can also try to make the picture nicer by changing positioning and other parameters.
But before doing this, make sure to implement the rest of the baseline functionalities!

You can return to image generation in the task where you are expected to change the URLs in the tram stops.
Right now, when you click at them, you should be taken to a Google search about that stop.

## Create dynamic content

The form `find_route.html` does not find any routes yet.
You can submit queries, but when you press "Search", the form just gets empty without any result being produced.
One effect happens, though: stop names that you have entered are remembered, at least for some time, so that it is easier to select them again.

So now we want to create a baseline functionality that actually shows the shortest path.
The following things are needed:

- a "utility" function that actually calculates the shortest path (from your Lab 2)
- an extended `find_route()` function in `tram/views.py` (to be copied from `files/`)
- a template that shows the route that is found (already copied from `files/`)

### Utility functions

It is a good practice to create a separate directory for "non-Django" utility functions and create an empty `__init__.py` file in it, so that it is recognized as a package.

```sh
$ mkdir tram/utils
$ touch tram/utils/__init__.py
```

Copy the following Python files from `lab3/files` into `tram/utils`:

- `graphs.py`, a mock-up, for the most part to be replaced by your Lab 2 version
- `trams.py`, a mock-up, for the most part to be replaced by your Lab 2
- `tramviz.py`, finding the shortest paths and marking them in SVG; for you TODO
- `color_tram_svg.py`, actually making the colouring in SVG, no need for you to touch

### Views revisited

Now that you have created the utility files, you can replace the simplified `tram/views.py` with the one given in `files`.

## Your TODO: continue from here

Now it is "just" your part of the work that remains.
Most of this work is to be done in the files in `tram/utils`.
They contain `TODO` comments that instruct you what to do.

The main function in the file `tram/utils/tramviz.py`, imported in `tram/views.py`, is `show_shortest`.
Its task is to

- find the shortest paths
- use them go colour the network picture
- show them in strings returned to `tram/views.py`

As the picture in `examples/show_route.html` shows, we expect three different colours to be used:

- green for stops on the shortest path
- orange for stops on quickest path
- cyan for stops that are on both paths

You can also use some other colours if you prefer.
Other stops should be left white.

The default implementation copied from `files/tramviz.py` is a mock-up, which always shows the same colours and the same route.

You can of course also makes the HTML files look nicer if you have time!

## Adding changes of lines

In Lab2 shortest path, we ignored the effect of changing from one line to the other.
This effect is that major factor that can make "shortest time" and "shortest distance" differ.
Its implementation requires that we recognize when a change must be made and add a suitable number of minutes or meters to the cost.

One way to do this with the existing algorithms is simply to build a new graph for the network, where

- vertices are pairs `(stop, line)` for each `stop` in the original graph and each `line` than passes through it,
- every edge `(a, b)` of the original graph is multiplied to edges `((a, line), (b, line))` for every `line` that serves both `a` and `b`,
- edges are added between all vertices that have the same `stop`,
- distances and transfer time between different stops are the same as in the original graph,
- a special change distance and change time is added between vertices that have the same stop but different times - for instance, 20 metres and 10 minutes, respectively.

## Adding links to actual traffic information

The challenge is to find the URLs corresponding to each stop name.
They are given as numerical codes, for instance, Nordstan is

```plain
https://www.vasttrafik.se/reseplanering/hallplatser/9021014004945000/
```

and its timetable is in

```plain
https://avgangstavla.vasttrafik.se/?source=vasttrafikse-stopareadetailspage&stopAreaGid=9021014004945000
```

The full list of stop identifiers can be found in

```plain
https://www.vasttrafik.se/reseplanering/hallplatslista/
```

The algorithm is as follows:

1. Investigate where and how Gids are given in the HTML document.
2. Extract the Gids of all tram stops from the document.
3. Create URLs for every stop.
4. Save the stop-URL dictionary as a JSON file

After this, you need to update the SVG image by these URLs. The simplest way to do this is as follows:

1. Run `files/create_network_picture.py` making sure that `TRAM_URL_FILE` and `MY_TRAMNETWORK_JSON` point to your URL dictionary and tramnetwork file, respectively.
2. Move the resulting file `my_gbg_tramnet.svg` to `tram/templates/tram/images/gbg_tramnet.svg`

Another possibility is process the file `gbg_tramnet.svg` directly.
You can do this by following the model of `tram/utils/color_tram_svg.py`.

**New 2024-12-16**: you can now do this with `files/change_urls.py`.
**Both methods should be applied outside your project environment, directly in `files` and only once.
Hence there is no need to copy those Python files from `files` to `tram/utils` or any such place.

After doing this, make another search in your web application and click at some stop to verify that the link has been updated.

The standard library for parsing HTML is

```plain
https://docs.python.org/3/library/html.parser.html
```

A slightly more convenient third party library can also be used, in the way explained in Lecture 8.

```plain
https://www.crummy.com/software/BeautifulSoup/bs4/doc/
```

## Submission

Via [GitHub Classroom](https://classroom.github.com/a/hnF26g57) as usual.
You are recommended to use `.gitignore` in order not to store the virtual environment directory.

Before inspecting your code, we will organize peer reviewing sessions, where each group tests and reviews some other group's lab.
The review report that you write will be added as a part of your submission.

[More details about peer reviewing](./peer-review.md)
